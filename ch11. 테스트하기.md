# 11 Chapter

> 품질은 그것을 위해 큰 대가를 지을 용의가 있는 자들에게만 꽁짜이다. - 톰 드마르코와 팀 리스터 '피플웨어'중에서

* 테스트 주도 개발, 즉 TDD(Test-Driven-Development)는 누군가애게는 종교와 다름없는 것이다. 하지만 다른 누군가에게는 단지 적절한 개발 방법일 뿐이다. 또 누군가에게는 괜찮은 생각이기는 하되 작업에 제대로 적용하기 어려운 것일 수 있다. 또 다른 누군가에게는 노력 낭비에 불과할 수도 있다. 과연 TDD란 무엇일까?

TDD는 더 나은 소프트웨어를 만들기 위한 중요한 기법 중 하나이다. 그런데 테스트 주도와 유닛 테스트가 실제로 무엇을 의미하는 가에 대해서는 명확하지 않은 점이 있다. 우선 이를 명확히 한 뒤 개발자 테스트에 대한 적절한 방법을 찾아본다면, 더 나은 코드를 짤 수 있을 것이다.

## 11.1 왜 테스트하는가

자신의 코드는 자신이 테스트해야 한다. 생각할 필요도 없는 당연한 일이다. 소프트웨어 개발자들이 자신의 새로운 코드가 작동하는지 확인해보는 것은 당연하다. 다만 일부 프로그래머들은 지나치게 확신에 차 있거나 오만한 나머지, 코드를 작성한 뒤 적절한 테스트도 하지 않고 배포해버린다. 이처럼 대충 작업하고 나면, 코드는 처음부터 정상적으로 작동하지 않는다. 문제는 QA 단계에서 발견되거나 사용자가 발견할 때까지 방치된다.

## 11.1.1 피드백 과정 줄이기

위대한 소프트웨어를 제대로 만들기 위해서는 피드백을 받아야 한다. 가능하면 자주 그리고 빨리 피드백을 받는 것이 좋다. 좋은 테스트 전략이란 피드백 절차를 간소화하는 것으로, 이를 통해 더 효율적으로 일할 수 있다.

 - 실제 사용하는 사용자에게 정확한 결과가 제공된다면, 해당 코드는 제대로 작동하고 있는 것이다. 코드가 적절히 작동하지 않고 정확한 결과를 제공하지 않는다면, 사용자는 프로그래머나 회사에 불평을 하게 된다. 이것이 유일한 피드백 과정이라면, 소프트워어 개발은 매우 더디고 들어가는 비용도 상당할 것이다. 여기에 그보다 더 나은 대안이 있다.
 - QA 팀에서 출시 후보 버전(Candidate Release)를 테스트 한다. 출시 전 적절하고 정확하게 작동함을 보장하기 위한 것으로, 이를 통해 피드백 과정은 더 줄어든다. 문제를 더 빨리 알 수 있고, 시장에 나간 뒤 발생한 문제에 소모되는 막대한 비용을 절약할 수 있다. 이보다 더 좋은 방법도 있다.
 - 새로운 하부 시스템(subsystem)을 새로운 프로젝트 전체에 통합하기 전에 확인할 수 있다. 개발자는 애플리케이션을 소스 관리 도구에서 브랜치하여 새로운 코드를 최대한 테스트해볼 수 있다. 이런 테스트가 적절하지 않은 경웨는 별도의 작ㅇ느 테스트용 애플리케이션을 만들어 테스트 해 볼 수 있다. 이러한 개발자 테스트를 통해 피드백과 과정을 더 줄일 수 있다. 이를 통해 코드가 의도대로 정확히 작동하는 지를 바로 확인할 수 있다. 다만 더 나은 방법이 여전히 남아 있다.
 - 하부 시스템은 더 작은(units) 부분으로 이루어져 있다. 클래스의 함수 수준에서 정확도와 품질에 대한 피드백을 쉽게 얻을 수 있다면, 피드백 절차를 더 줄일 수 있다. 가장 작은 수준에서의 테스트를 통해 가장 빠른 피드백을 얻을 수 있다는 말이다.

피드백 과정이 짧을 수록 설계 변경을 더 빠르게 반복할 수 있고, 코드에 대해 더 강하게 확신할 수 있다. 문제를 빨리 알수록 수정은 쉬워지고 비용은 낮아진다. 그 이유는 코드를 짜는 시점에 가까운 만큼 코드에 대해 더 명확하게 파악하고 있기 때문이다.

> 소프트웨어 개발과정을 개선하려면 빠른 피드백을 통해 문제 파악에 소모되는 시간을 중여야 한다. 좋은 테스트 전략이란 바로 피드백 절차를 줄이는 데 있다.

QA 팀이나 개발자에 의해 수행되는 수작업 테스트(manual tests)는 손이 많이 가고 속도가 느리다. 포괄적인 테스트가 되기 위해서는, 수많은 개별적 단계들을 통해 코드에 약간의 수정을 가할지언정 그때그때 반복 수행할 수 있어야 한다.

여기서 잠깐! 반복적이고 손이 많이 가는 작업은 컴퓨터가 잘하는 일이 아닌가? 자동으로 테스트를 수행할 때는 컴퓨터를 사용하면 될 일이다. 컴퓨터를 사용하여 테스트하면 테스트 수행시간과 피드백 과정을 더 줄일 수 있다.

자동화된 테스트를 통해 피드백 과정을 줄이면, 코드 개발과정에 도움이 될 뿐만 아니라 재활용도 가능하다는 이점이 있다. 즉, 한 번 일련의 테스트 코드를 작성하고 나면 테스트 풀에 넣어두고 계속해서 돌릴 수 있다. 이렇게 되면 테스트 코드가 탄광 속의 카나리아 역할을 담당하여 문제가 심각해지기 전에 경고를 보낼 것이다. 훗날 누군가 잘못된 형태로 코드를 수정해도, 테스트를 통해 즉시 문제를 알아낼 수 있다. 그 누군가란 컨디션이 좋지 않던 날의 코드 작성자 자신일 수도 있다.

# 11.1.2 테스트 코드 짜기

결국 가장 이상적인 방법은 최대한 많은 개발자 테스트를 자동화하는 것이다. 더 열심히 일하려 하기보다 더 영리하게 일하라. 통합 개발환경은 타이핑 할 때마다 문법 오류를 강조해 줄 것이다. 이와 같은 속도로 테스트를 통해 확인한 오류를 보여준다면 좋지 않겠는가?

컴퓨터는 테스트를 빠르고 반복적으로 수행함으로써 피드백 과정을 줄일 수 있다. 물론 UI테스트 도구를 통해 데스크탑 애플리케이션을 자동으로 테스트하거나, 브라우저 기반의 테스트 도구를 통해 웹 어플리케이션을 자동으로 테스트할 수도 있다. 그러나 대부분의 경우 개발자 테스트는 별도의 프로그램을 작성하고 테스트 대상 시스템(SUT : System Under Test)에 대한 테스트를 자동으로 수행하여 그 반응이 적절한지 확인한다. 즉 코드를 테스트하기 위해 코드를 짜는 것이다. 이 얼마나 이상적인 상황인가.

사실 이런 테스트 코드를 작성하려면 소중한 시간을 들여야 한다. 코드에 대한 확신은 곧 테스트 코드의 품질에 따라 결정된다. 하지만 코드의 품질을 높일 수 있고 코드 작성 결과가 안전해지는 테스트 전략을 채택하는 것은 그리 어려운 일이 아니다. 이를 통해 오히려 코드 작성 시간을 줄일 수 있다. 즉 더 서둘러야 하는 상황에서는 오히려 더 천천히 가라는 것이다. 실제로 여러 연구에 따르면, 적절한 테스트 전략이야말로 불량 발생률을 줄일 수 있는 것으로 증명되었다.

물론 테스트로 인해 속도가 더뎌질 수도 있다. 테스트를 제대로 이해하지 못하여 코드 작성 중에 테스트로 인한 오류가 마구 발생하거나, 또는 코드 구조가 경직되어 하나의 함수 일부를 고치는 데 수백만 개의 테스트를 재작성해야 하는 경우가 그렇다. 그러나 이는 잘못된 테스트 코드들을 작성하면 안되는 이유일 뿐, 테스트를 하지 말아야 하는 이유는 될 수 없다. 나쁜 코드가 프로그래밍 자체를 금지해야 하는 이유가 되지 못하는 것과 같은 이치이다.

# 11.1.3 누가 테스트 코드를 짜야 할까

과거에 어떤 이들은 원 저자의 코드를 검증하는 데 특화되고 유닛 테스트 작성에 전념하는 별도의 역할이 필요하다고 여겼다. 하지만 가장 적절한 방법은 코더 자신이 자신의 코드에 대한 테스트 코드를 작성하는 것이다. 즉 코드를 작성하면서 자신이 그 코드를 테스트하는 것이다.
> 모든 단계의 소프트웨어 스택과 개발 프로세스에 대해 테스트를 수행해야 한다. 특히 가장 작은 범위에서 테스트해야 한다. 그래야만 피드백 과정을 줄이고 가능한 한 빠르고 쉽게 고품질의 소프트웨어를 만들 수 있다.

# 11.2 테스트 유형

세상에는 많은 종류의 테스트가 있다. 누군가가 'Unit Test'에 대해 이야기할 경우, 서로 다른 코드 테스트를 의미할 수도 있다. 테스트 유형은 다음과 같다.

### 유닛 테스트(Unt tests)
유닛 테스트란 가장 작은 단위의 기능에 대한 테스트를 단독으로 수행하는 것으로, 각각의 함수가 정확히 작동하는지 확인하기 위한 것이다. 즉 출시 코드에 다른 단위들이 포함됮 않은 채, 단일 단위의 코드(하나의 클래스 혹은 함수)에 대해 테스트가 수행되지 않는다면, 그것은 유닛 테스트가 아니다. 이 단독이란 말ㅇ느 그 어떤 외부에 대한 접속도 하지 않는다는 뜻이다. 데이터베이스와 네트워크, 파일 시스템 없이 실행된다는 뜻이다. 보통 유닛테스트의 코드는 잘 알려진 'xUnit' 형태의 프레임워크를 이용하여 작성된다. 모든 언어와 환경에서는 이런 종류의 프레임워크가 있고, 그 중에는 사실상 표준인 프레임워크도 있다. 테스트 프레임워크에 특별한 게 있는 것은 아니므로, 시간이 더 걸리더라도 전통적인 assert를 통해 직접 유닛 테스트를 작성해도 된다. 프레임워크에 대해서는 나중에 알아보도록 하겠다.

### 통합 테스트(Integration tests)
통합 테스트를 통해 각각의 단위 모듈을 더 큰 결합체로 통합하여 작동시키는 복합 기능을 검증할 수 있다. 통합된 단위 요소들이 서로 잘 통합되어 있고, 정확하게 상호 작동하는 지 확인할 수 있다. 통합테스트는 보통 유닛테스트 코드 작성 시 사용하는 것과 같은 프레임워크를 사용하여 작성한다. 차이가 있다면 테스트 대상이 되는 범위뿐이다. 많은 사람이 말하는 유닛테스트는 실제로는 통합테스트 수준의 테스트로써, 테스트 대상이 하나 이상의 객체들인 테스트를 의미한다. 사실 이 테스트의 존재 자체가 중요하지 테스트의 명칭은 중요하지 않다.

### 시스템 테스트(System tests)
'종단 간 테스트(End-to-end tests)'라고도 알려진 이 테스트를 통해 전체 시스템에 대한 요구사항 명세를 확인할 수 있다. 통합된 소프트웨어 스택 전체에 수행되는 테스트로써, 프로젝트에 대한 검수 기준으로 사용된다.
시스템 테스트는 외부노출 API나 시스템 시작점에 대해 실행되는 코드로 작성될 수 있다. 혹은 셀레니움 같은 웹브라우저 자동화 도구를 통해 시스템외부에서 수행될 수도 있다. UI 단계를 통해 애플리케이션의 전체 기능을 실질적으로 테스트하기 어렵다면, 바로 아래 단계에서 코드를 직접 실행하는 형태의 테스트를 수행할 수도 있다. 시스템 테스트는 범위가 넓은 탓에 전체 테스트를 수행하는 데 많은 시간이 걸릴 수 있다. 많은 네트워크 트래픽이 유발되거나 느린 데이터베이스 접속이 필요할 수도 있다. 혹은 시스템 테스트를 할 때마다 테스트 대상 시스템(SUT)에 테스트를 붙이거나 떼어내느라 막대한 비용이 소요될 수 있다.


##
각 단계의 개발자 테스트에서 SUT에 대한 정의들을 수립하고, 이들을 증명하는 일련의 테스트 케이스를 수립한다. TDD에는 여러 형태가 있다. 어떤 프로젝트는 유닛 테스트 사고방식에 따라 진행될 수도 있다. 이 경우 시스템 테스트보다는 통합 테스트가 많고 통합 테스트 보다는 유닛 테스트가 많다. 혹은 시스템 테스트 사고방식에 따라 진행될 수도 있다. 이 때는 앞에서와 반대로 유닛 테스트가 가장 적다. 각각의 테스트는 각자의 위치에서 모두 중요하므로, 성숙한 소프트웨어 프로젝트에는 모두 존재해야 한다.

# 11.3 언제 테스트를 작성할까

TDD란 용어는 테스트 우선 개발(Test-First-Development)이라는 용어와 통합되어 있다. 하지만 이 둘은 서로 별개의 용어이다. 독단적으로 테스트를 먼저 작성하지 않아도, 테스트를 통한 피드백을 통해 설계를 개선해나갈 수 있다.
하지만 테스트 작성을 미룰수록 테스트는 덜 효과적이게 될 것이다. 코드가 어떻게 작동할지를 잊어버리거나, 극단적인 경우에 대한 테스트를 작성하지 못할 수도 있따. 혹은 아예 테스트 코드 작성을 잊어버릴 수도 있따. 테스트 작성을 미룰수록 피드백 절차는 더 늦어지고 덜 효과적이게 될 것이다.
테스트 우선의 경우, 흔히 XP라 통용되는 익스트림 프로그래밍(Extreme Programming) 진영에서 자주 볼 수 있다. 이때 '실패 테스트를 작성하기 전에 그 어떤 코드도 작성하지 말라'는 지침은 진리나 다름없다. 테스트를 우선으로 하는 TDD의 단계는 다음과 같다.

1. 다음으로 구현해아 하는 기능을 결정한 뒤, 해당 기능에 대한 테스틀 작성하라, 물론 테스트는 실패할 것이다.
2. 테스트를 작성한 뒤 최대한 간단한 방법으로 기능을 구현하라. 테스트를 통과했다면 기능이 적절히 구현되었음을 알 수 있다. 코드를 작성하면서 여러 번 테스트를 수행하게 될 것이다. 각 단계에서 작은 기능을 추가하면서 작은 테스트도 함께 추구한다. 각 테스트가 작은 만큼 실행도 빠르다.
3. 중요하지만 자주 간과되는 부분이 있다. 코드를 정리하라. 이상한 공통분모를 리팩토링하라. 테스트 대상 시스템(SUT)을 재구조화하여 더 나은 내부 구조로 만들라. 그 무엇도 잘못되지 않게 만들 수 있다는 확신을 가지고 작업해도 된다. 일련의 테스트를 통해 모두 검증할 수 있기 때문이다.
4. 첫 단계로 돌아가서, 요구사항에 대한 테스트 케이스 전체를 통과할 때까지 테스트를 반복하라.

짧은 피드백 과정의 강력하면서도 매력적인 일례로서, 이는 레드-그린-리팩토링 주기로도 불린다. 이는 테스트 실패인 경우 빨간색으로 보여주고 테스트 성공인 경우 녹색으로 보여주는 유닛 테스트 도구를 감안한 용어이다.

설령 테스트 우선이라는 진언에 경의를 표하지 않더라도, 피드백 절차를 줄이고, 특정 범위에 대해 코드를 작성해가며(혹은 코드를 작성한 직후) 해당 범위에 대한 유닛 테스트 코드를 작성하라. 유닛 테스트를 통해 설계를 실제로 진행할 수도 있다. 모든 것이 기능적으로 정확성을 보장하고 퇴행을 방어할 뿐만 아니라, 클래스 API가 실제로 어떻게 사용될 지 그리고 얼마나 간결한지 확인할 수 있는 최고의 방법이다. 이는 소중한 피드백이다. 또한 테스트와 클래스 작성을 마치고 나면, 테스트 코드는 클래스 사용에 대한 유용한 문서가 될 수 있다.
> 코드를 작성하면서 테스트를 같이 작성하라. 테스트 작성을 미루면 그만큼 테스트 효과가 줄어들 것이다.

이처럼 빠르게 자주 실행하는 테스트 접근 방법은 유닛 테스트와 통합 테스트, 시스템 테스트 모두에 적용할 수 있다. 설령 프로젝트가 자동화된 시스템 테스트를 위한 기반 구조를 포함하지 않는다 해도, 프로그래머는 책임을 지고 유닛 테스트와 더불어 작성한 코드를 검증해야 한다. 이는 그리 큰 비용이 들지 않으며, 코드 구조가 좋다면 크게 어려운 일도 아니다.

테스트 작성을 위한 또 하나의 적절한 시기는 바로 출시 코드에 대해 버그를 수정할 때이다. 코드 수정에 무작정 달려들기보다는 우선 보그의 원인을 설명하는 실패 유닛 테스트를 작성하라. 때로눈 이 테스트를 작성하는 과정에서 다른 관련 버그를 찾아낼 수도 있다. 그런 뒤에 버그를 수정하고 테스트를 통과하도록 하라. 테스트 풀에 테스트를 집어넣고 나면, 이후 다시는 또같은 버그가 나타나지 않도록 항상 테스트할 수 있다.

# 11.4 언제 테스트를 실행하는가
> 단지 바라보는 것만으로도 많은 것을 알 수 있다 - 요기 베라

테스트 코드를 TDD를 사용해 개발하면, 각각의 기능을 구현하면서 테스트를 계속 실행할 수 있다. 정확하고 충분하게 구현되었는지 지속적으로 검증할 수 있다. 테스트 코드 사용법은 이에 국한되지 않는다. 버전 관리 도구에 구현 코드와 테스트 코드를 모두 추가하라. 테스트는 사라지지않고 이전부터 존재해온 테스트들과 함께 하게 된다. 소프트웨어가 지속적으로 기대에 걸맞게 작동하는지 확인하며, 코드와 함께 살아간다. 만약 이후에 누군가 코드를 잘못 수정한다면, 너무 늦어버리기 전에 그에 대한 경고를 받게 될 것이다.

모든 테스트는 지속적 통합(CI : Continuous Integration) 도구의 일부인 빌드 서버에서 실행해야 한다. 유닛 테스트는 개발 머신에서 자주 실행해야 한다. 일부 개발 환경의 경우 유닛 테스트를 쉽게 실행할 수 있는 간단한 경로를 제공한다. 어떤 시스템에서는 파일 시스템을 검색하던 중 파일이 변경되면 유닛 테스트를 실행하기도 한다. 하지만 필자의 경우 빌드-컴파일-실행 과정에 테스트를 녹여넣는 것을 선호한다. 만약 일련의 유닛 테스트가 실패하면, 컴파일 자체를 실패한 것으로 간주하여 소프트웨어가 실행되지 않을 수 있다. 이런 방법을 사용하면 테스트를 무시할 수 없으며 코드를 빌드할 때마다 테스트를 수행하게 된다. 수작업으로 실행할 경우에는 개발자들이 테스트 실행을 잊어버릴 수도 있고, 혹은 일하는 중이니 귀찮아서 건너뛸 수도 있다. 빌드 과정에 테스트를 끼워넣을 수 있도록 테스트를 작성하는게 좋다.
> 테스트를 빠르게 자주 수행하라. 빌드 과정에 테스트를 통합하라.

통합 테스트와 시스템 테스트는 개발 멋니에서 컴파일 때마다 수행되면 너무 오랜 시간이 걸릴 수 있다. 이런 경우에는 CI 빌드 서버에서만 적절히 수행될 수 있다. 코드 수준의 자동화된 테스트를 하더라도, 출시 전 사람에 의한 QA 검수 과정은 필요하다. 진정한 테스트 전문가에 의한 탐색적 테스트는 매우 유용하다. 이는 얼마나 많은 유닛 테스트나 통합 테스트, 시스템 테스트가 존재하는가와는 별개의 문제다. 자동화된 일련의 테스트를 이용하면, QA과정에서 간단한 버그들을 찾아내느라 시간을 낭비하지 않아도 된다. QA 전문가들은 간단한 버그뿐 아니라 정말 심각한 버그들도 찾아낼 수 있다는 점을 명심하자!
> 아무리 좋은 개발자 테스트라 해도 QA 테스트를 대체할 수는 없다

# 11.5 무엇을 테스트할 것인가

애플리케이션에서 중요한 부분은 모두 테스트하라. 당신의 요구사항은 무엇인가? 테스트를 통해 요구사항에 맞게 각각의 코드가 작동하는지, 그리고 각 코드가 정확한 결과를 반환하는지 확인할 필요가 있다. 하지만 애플리케이션에 있어서 성능이 주요 요구사항이라면, 코드의 성능을 모니터링하는 테스트도 수행해야 한다. 서버에서 특정 시간대에 어떤 응답을 해야 한다면, 그 조건에 대한 테스트도 포함하라.
테스트를 수행하는 구현 코드의 범위(coverage)에 대해서도 고려할 수 있다. 이를 위해 도구를 실행해볼 수 있지만, 계속해서 고려하기에는 이상한 지표일 수 있다. 모든 구현 코드를 다루기 위해 힘들게 테스트 코드를 작성하는 것은 정신적으로 매우 힘든 일이다. 가장 중요한 행태와 시스템의 성격에 집중해야 한다.

# 11.6 좋은 테스트

좋은 테스트 코드를 작성하려면 연습과 경험이 필요하다. 나쁜 테스트 코드를 작성하는 일은 언제든지 가능하다. 그렇다고 처음부터 너무 걱정할 필요는 없다. 테스트 작성을 시작하는 것이 가장 중요하며, 테스트가 쓸모없을까 걱정하여 무력해져서는 안 된다. 테스트를 쓰기 시작하고 배워나가라.

나쁜 테스트는 짐이 된다. 자산이기보다는 채무이다. 나쁜 테스트로 인해 테스트 수행에 오랜 시간이 걸린다면 개발 과정 역시 더뎌질 뿐이다. 간단히 코드를 수정했는데도 읽기 힘든 테스트 결과를 뱉어낸다면, 코드 수정이 어려워질 수 있다.

테스트 수행에 시간이 오래 걸릴수록 테스트 수행과 이용 빈도가 줄어들 것이고, 피드백 역시 조금만 받게 될 것이다. 즉 더 적은 가치를 얻게될 것이다. 

필자는 예전에 많은 양의 유닛 테스트를 포함하는 코드베이스에서 작업을 시작한 경험이 있다. 이는 엄청난 징후였는데, 슬프게도 그 테스트들이 구현 코드들보다 더욱 심각하게 나쁜 레거시 코드였다. 코드에 약간만 수정을 가해도 처리하기 어렵고 조밀하며 이해하기 힘든 엄청나게 많은 테스트 실패 결과를 뱉어냈다. 다행히도 이 같은 경험이 일반적인 것은 아니다.
> 나쁜 테스트는 부채가 될 수 있다. 이로 인해 개발 과정이 지연될 수 있다.

* 다음의 좋은 테스트의 특징이다.
- 짧고 명확한 이름을 가지고 있어 실패했을 때 무엇이 문제인지 쉽게 알 수 있다.(예 : 새 리스트가 비었음)
- 유지 보수가 가능하다. 작성은 물론 읽고 수정하기도 쉽다.
- 수행에 오랜 시간이 걸리지 않는다
- 최신 구현 코드에 맞춰져 있다
- 특별한 머신 설정이 필요 없다(예 : 파일시스템의 경로를 조정하거나 데이터베이스를 설정할 필요가 없다)
- 다른 테스트에 대한 의존성이 없어서 특정 테스트 전후에 실행할 필요가 없다. 외부 상태나 코드상의 어떤 공유 변수에 대한 의존성이 없다.
- 실제 구현 코드를 테스트한다.(필자는 구현 코드의 복제본에 대한 유닛 테스트를 본 적이 있다. 그 복제본은 최신 버전이 아니었던데다 쓸모도 없었다. 또한 테스트 빌드 과정에서 SUT에 덧붙이는 특별한 테스트 행태를 본 적도 있따. 이 역시 실제 구현코드에 대한 테스트가 아니었다)

* 다음은 나쁜 테스트에 대한 설명이다.
- 때로는 성공하고 때로는 실패하는 테스트(발생 요인으로는 스레드 사용, 특정 시점에 발생하는 경쟁 조건, 외부의존성, 테스트 간 순서, 공유 상태 등을 꼽을 수 있다)
- 이상해 보이고, 읽거나 수정하기 힘든 테스트
- 지나치게 큰 테스트(큰 테스트 코드는 이해하기 힘들다. 테스트 준비를 위해 수백 줄의 코드가 필요하다면 SUT 자체가 이미 독립적으로 작성되지 않은 것이다)
- 하나의 테스트 케이스에서 둘 이상을 수행하는 테스트
- 클래스 API에 대해 개별 형태를 확인하는 것이 아닌 함수마다 공격을 하는 테스트
- 직접 작성하지 않은 서드파티 코드에 대한 테스트(믿지 못할 이유가 있는 것이 아니라면 테스트를 수행할 이유가 없다)
- 클래스의 중요 기능이나 행태에 대해 실제로 테스트를 하지 않는데다 별다른 필요없는 테스트들로 상황을 숨기는 테스트(이런 테스트가 가능하다면 클래스가 지나치게 큰 경우일 수도 있다)
- 지나치게 상세하여 중구난방인 테스트(예 : 속성의 getter와 setter에 대한 테스트)
- SUT의 내부 구현에 대한 지식을 바탕으로 한 화이트박스식 테스트(이는 구현 변경 시에 테스트도 변경해야 한다는 것을 뜻한다)
- 단 하나의 머신에서만 수행 가능한 테스트

때론 나쁜 테스트란 테스트 자체 뿐만 아니라 테스트 대상 코드(SUT)가 나쁘다는 점을 의미하기도 한다. 이러한 점을 잘 살펴보고 코드의 설계를 개선해야 한다.

# 11.7 테스트는 어떠해야 하는가

테스트 프레임워크에 따라 테스트 코드의 형태가 결정된다. 구조화된 테스트 상황 설정기능과 테스트 상황 해제 기능, 그리고 커다란 결합체로서 개별 테스트를 그룹화하는 방법을 제공할 수 있다.
일반적으로 각 테스트에는 몇 가지 준비 과정이 필요하고, 준비가 되면 실제 실행하게 되며, 마지막으로 실행 결과를 검증한다.이것이 바로 배치-실행-확인(arrange-acat-assert) 패턴이다. 유닛 테스트에서는 일반적으로 확인 단계에서 한 가지만 확인한다. 만약 여러가지를 확인해야 한다면, 하나의 테스트 케이스만으로는 다룰 수 없다.

다음은 앞에서 설명한 패턴을 따르는 Java 유닛 테스트의 예제이다. 이 패턴을 유지하면 테스트에 집중하고 읽기 쉽게 만들 수 있다.

 	@Test

	public void stringsCanBeCapitalized(){

	String input = "This string should be uppercase";
	String expected = "THIS STRING SHOULD BE UPPERCASE";
	
	String result = input.toUpperCase();

	assertEquals(result, expected);
 
- > arrange(배치) : 입력을 준비한다.

- > act(실행) : 실제로 실행한다.

- > assert(확인) : 실행 결과를 확인한다.

물론 앞에서 소개한 테스트만으로는 문자열의 대문자로의 변환과 괸련된 모든 경우의 수를 커버할 수 없다. 다른 입력 값과 그에 대한 기대 결과를 다루는 테스트들도 필요하다. 각 테스트는 새로운 테스트 함수로 만들어져야 하며, 다른 테스트에 통합되어서는 안 된다.

# 11.7.1 테스트 이름

하나의 기능 검증에 집중하는 테스트에는 명확한 이름이 붙어 있어서 간단한 문장처럼 읽힌다. 만약 테스트 케이스 이름을 간단히 붙일 수 없다면, 요구 사항이 모호하거나 혹은 여러 가지를 한꺼번에 테스트하려는 것일 수 있다.

앞에서 본 바와 같이, 테스트 메서드에는 @Test와 같은 특성이 지정되므로 메서드 명에 test라는 단어를 포함시킬 필요는 없다. 다시 말해 예제의 메서드 명을 testThatStringCanBeCapitailized로 지을 필요가 없다.

테스트들이 코드에 대한 명세 사항으로 읽힌다고 가정하라. 각 테스트의 이름은 테스트 대상 시스템(SUT)을 실행하는 것에 대한 설명, 즉 단 하나의 정의에 대한 설명이다. 'should'나 'must'와 같이 실제 행위에 대한 것이 아닌 단어를 쓰지 말라. 구현 코드를 작성할 때와 마찬가지로, 불필요하게 긴 이름은 피하라.

테스트의 이름을 굳이 구현 코드와 같은 형식으로 지을 필요는 없다. 각자 서로에게 맞는 영역의 언어가 있을 수 있다. 보통 더 길면서 서술적인 메서드 명에 언더바를 자유롭게 쓰는 경우를 많이 볼 수 있다. 언더바가 관용적이지 않은 C#이나 Java에서도 마찬가지다. 예를 들어 stringts_can_be_capitaliazed와 같은 이름은 읽기 쉽다.

# 11.8 테스트 구조

테스트가 코드의 중요 기능을 모두 다룬다는 점을 보장하라. '정상적인' 입력 값들은 물론, 일반적인 실패 케이스를 비롯해 빈 값이나 0과 같은 경계값에서 발생할 수 있는 모든 경우의 수를 고려하라. 시스템 테스트와 통합 테스트를 통해 전체 시스템의 모든 요구사항 및 기능을 다루고, 유닛 테스트를 통해 모든 기능을 다루려는 목표는 칭찬할 만하다. 하지만 만만치 않은 노력을 들여야 한다.

테스트는 중복해서 수행하지 않는다. 중복수행은 노력과 혼란, 유지 보수 비용을 가증시킨다. 각 테스트 케이스는 하나의 정의만을 검증해야 한다. 테스트를 재차 수행하거나 다른 테스트의 일부로서 다시 그 정의를 검증할 필요는 없다. 먼저 수행하는 테스트에서 객체를 생성한 후의 선행 조건을 확인하였다면, 그밖의 모든 테스트에서는 이 선행 조건을 만족하고 있다고 가정할 수 있다. 객체를 생성할 때마다 일일히 확인할 필요는 없다.

흔히 저지르는 실수는 5개의 메서드를 가진 클래스를 확인하게 위해 5개의 테스트를 해아 한다고 생각하는 것이다. 이해할 수는 있지만 순진한 접근법이다. 함수 단위의 테스트는 거의 소용이 없는데, 하나의 함수만 단독으로 테스트하기 어렵기 때문이다. 하나의 메서드를 호출한 후에 다른 메서드를 호출해봐야만 객체의 상태를 확인할 수 있다. 코드의 특정 행태를 확인하는 테스트를 작성하라. 이를 통해 더 응집되고 명확한 테스트를 작성할 수 있다.

# 11.8.1 테스트 유지 보수

테스트 코드는 구현 코드만큼 중요하므로, 테스트 코드의 외관과 구조를 적절하게 다듬어야 한다. 엉망이 되어버렸다면, 낄끔하게 다듬고 리팩토링 하라.

클래스의 행태를 변경한 탓에 테스트를 실패했다고 해서 테스트를 막아버리고 도망쳐서는 안된다. 테스트 코드도 유지보수하라. 완료 일정을 맞추기 위해 테스트 코드를 깔끔히 하는 작업을 무시하고 싶은 충동을 느낄 수도 있다. 하지만 서두르는 과정에서 세심하지 못하면 결국 뒤통수를 맞게될 것이다.

필자는 예전에 한 프로젝트에서 동료로부터 다음과 같은 이메일을 받았다. "당신의 XYZ 클래스에 대해 작업하던 중에, 유닛 테스트가 작동하지 않아 모두 삭제해버렸습니다." 놀란 필자는 어떤 테스트 코드가 삭제되었는지 살펴보았다. 슬프게도 새 코드의 근본적인 문제를 알려주는 중요한 테스트 케이스였다. 그래서 필자는 테스트 코드를 살린 후에 버그를 수정하였다. 그런 다음 새로운 요구사항에 적합한 새로운 테스트 케이스를 고안했고, 과거의 테스트와 새로운 테스트를 모두 만족시키도록 다시 코드를 작성했다.
> 테스트 코드를 유지 보수하고, 테스트 코드 결과에 주의를 기울이라

# 11.8.2 테스트 프레임워크 고르기

유닛 테스트 혹은 통합 테스트에서 사용되는 프레임워크에 따라 테스트 코드의 외관과 체크 형태, 그리고 구조가 결정된다. 예를 들어 '테스트 케이스를 자유롭게 함수로 구현하는가? 아니면 정해진 형태의 테스트 클래스 내에 메서드로 구현하는가'와 같은 것이다.

따라서 좋은 유닛 테스트 프레임워크를 선택하는 게 중요하다. 너무 복잡하거나 기능이 많을 필요는 없다. 거추장스러운 도구는 고르지 않는 편이 낫다. 그냥 assert 함수를 사용핻오 된다는 점을 기억하라. 필자의 경우 main 메서드와 일련의 assert들로 초기 구현 코드에 대한 테스트 코드를 작성하곤 한다.

대부분의 테스트 프레임워크는 smalltalk를 위해 켄트 백이 만든 오리지널 sUnit 프레임워크로부터 유래한 'xUnit' 모델을 따른다. 이 모델은 JUnit이라는 Java를 위한 프레임워크에서 차용되어 유명해졌는데, 대부분의 언어에 대해 거의 비슷하게 구현되었다. 예를 들면 C#에 대한 NUnitrhk C++에 대한 CppUnit이 그것이다. 다만 이러한 프레임워크가 언제나 이상적이라고는 할 수 없다. xUnit 형태의 테스트 방식은 일부 언어에서는 관용적이지 않은 측면이 있다. 예를 들어 C++에서는 볼품없는 반면 Catch와 같은 다른 테스트 프레임워크에선 잘 작동한다.

어떤 프레임워크는 예쁜 GUI를 제공하는데, 여기서는 테스트의 성공과 실패를 명확히 알 수 있도록 녹색 막대와 빨간 막대로 표시되어 있다. 보기엔 즐거울 수 있겠지만 필자는 썩 좋아하지 않는다. 필자의 생각으로는 굳이 별도의 UI나 실행 과정이 필요하지 않다. 그냥 빌드 과정에 포함시키는 게 이상적으로 보인다. 구현 코드 작성 중에 발생하는 다른 오류들처럼 빌드 과정에서 즉시 피드백을 확인할 수 있어야 한다.

시스템 테스트에는 다른 형태의 프레임워크를 사용하는 경향이 있다. Fit이나 Cucumber와 같은 도구들이 그것이다. 이런 도구들은 좀 더 인간적이면서도 코드를 짜는 것이 아닌 방식으로 테스트를 정의하려는 경향이 있다. 따라서 프로그래머가 아닌 사람들도 테스트나 기능 명세 작성 과정에 참여할 수 있다.

# 11.9 어떤 코드도 혼자가 아니다

유닛 테스트 코드를 작성할 때는 독립화된 유닛의 코드를 테스트 대상 시스템에 넣는 것을 목표로 한다. 이 유닛은 나머지 시스템 없이도 존재할 수 있어야 한다. 하나의 유닛이 외부 세계와 연계되는 방식은 두 가지 형태의 계약 조건으로 표현할 수 있다. 하나는 제공하는 인터페이스이고 다른 하나는 제공받는 인터페이스이다. 유닛은 다른 것에 의존적이어서는 안 된다. 특히 공유된 글로벌 상태나 싱글톤 객체들은 의존적인 면이 강하다.
> 글로벌 변수나 싱글톤 객체는 신뢰할 만한 테스트에 대한 저주와 같다. 숨겨진 의존성이 있다면 하나의 유닛을 쉽게 테스트할 수 없다.

하나의 코드 유닛이 제공하는 인터페이스는 단순히 어떤 메서드이거나 멤버 함수, 이벤트, 속성일 수 있다. 또는 콜백 형태의 인터페이스일 수도 있다. 이러한 인터페이스는 API를 통해 상호 작동하는 객체들에 의해 결정된다. 공개 메서드에 쓰이는 매개 변수의 자료형일 수도 있고, 구독하고 있는 메시지일 수도 있다. 예를 들어 Date 매개변수를 요구하는 Invoice 클래스의 경우 Date 자료형의 인터페이스에 의존적이다.

하나의 클래스와 상호 작동하는 객체들은 생성자의 매개 변수로서 전달되어야 한다. 이를 '상위로부터의 매개 변수화'라고 부른다. 이를 통해 클래스의 다른 코드에 대한 직접적인 의존성을 줄이고, 그것들이 간접적으로 호출되도록 할 수 있다. 다시 말해 클래스와 상호 작동하는 객체들의 자료형에 대해 직접적으로 의존하기보다 객체들이 특정 인터페이스를 통해 간접적으로 연결되므로써, 클래스와 객체들 간의 상호 작동에 대한 테스트를 수행할 수 있다. 또한 해당 인터페이스를 통해 다른 형태의 구현체를 만들어 테스트를 수행할 수도 있다.

이는 테스트를 통해 더 잘 구성된 코드를 설계하는 법에 대한 하나의 사례이다. 이를 통해 직접 연ㄱ려된 관계나 내부적인 조건들을 제거할 수 있다. 특정 상호 작동을 정의하는 인터페이스를 최소화하는 훌륭한 일례로서, 작동이 전체 클래스에 의존하기보다 간단한 인터페이스에 의존하도록 할 수 있다.
> 코드를 잘 테스트할 수 있도록 팩토링하면, 더 나은 코드 설계를 할 수 있다. p145 

외부 인터페이스에 의존하는 객체를 테스트할 때, 테스트 케이스에서 해당 인터페이스에 대한 견본을 제공할 수 있다. 테스트 진영에 따라 용어는 다를 수 있으나 보통 테스트 대역(test double)이라 부른다. 대역에는 다양한 형태가 있으며 일반적으로 사용하는 형태는 다음과 같다. 

#### 견본(Dummies)
견본 객체는 보통 빈 껍데기다. 테스트에는 견본을 실행하지는 않지만, 인자 목록을 채우기 위해 필요하다.

#### 짝 (Stubs)
짝 객체는 인터페이스의 단순화된 구현체로서, 미리 정의된 응답을 반환하고 자신에 대한 호출과 관련된 정보를 저장하곤 한다.

#### 목(Mocks)
목 객체는 테스트 대역 중 최고로 여러 모조 객체 지원 라이브러리 기능을 한다. 목 객체는 명시적인 인터페이스에서 자동으로 생성될 수 있고, 테스트 대상 시스템에서 어떻게 사용될지에 대해 미리 전달받을 수 있다. SUT 테스트를 수행한 뒤에, 목 객체를 확인하여 기대한 바와 같은 행위를 하였는지 확인할 수 있다.
언에에 따라 목 객체 지원 프레임워크에 대한 지원 여부나 방법이 다르다. 리플렉션 기능이 있는 언어의 경우 목 객체를 동기화하기 더 쉽다. 목 객체를 적절히 사용하면 테스트가 더 간단하고 쉬워진다. 하지만 그것은 남용하기도 쉽다. 너무 많은 목 객체들을 복합적으로 사용하여 테스트가 엉켜버리면, 문제를 파악하기 어렵고 유지 보수도 쉽지 않다. 즉 목 객체를 지나치게 사용하면 나쁜 테스트 코드가 되기 쉽고, SUT의 구조가 정확하지 않다는 징후가 될 수도 있다.

# 11.10 마치며

테스트는 코드 작성에 도움을 준다. 테스트를 통해 좋은 코드를 작성할 수 있고 코드의 품질을 유지할 수 있다. 테스트를 통해 코드의 설계를 개선할 수 있으며, 코드가 구현하는 기능을 어떻게 사용할지 문서화할 수 있다. 하지만 소프트웨어 개발 과정에서 발생하는 모든 문제를 해결할 수는 없다. 컴퓨터 과학자였던 에츠허르 데이크스트라는 이렇게 말했다. "프로그램 테스트를 통해 버그의 존재를 확인할 수는 있지만, 버그가 없음을 확신할 수는 없다."

어떤 테스트도 완벽하지는 않지만, 테스트의 존재를 통해 작성 중인 코드나 유지 보수하는 코드에 대한 확신을 키울 수는 있다. 개발자 테스트에 들이는 노력은 물물교환과 같다. 즉 확신을 얻기 위해서 얼마나 많은 노력을 테스트 작성에 투자할 것인지의 문제다. 테스트 모음이 얼마나 쓸모있는지는 포함된 테스트가 얼마나 쓸 만한가에 달려 있음을 기억하라. 중요한 테스트 케이스를 완전히 잊어버릴 수도 있따. 출시해버린 채 문제를 구대로 내버려둘 수도 있다. 이런 이유로 구현 코드만큼이나 테스트 코드를 주의 깊에 살펴봐야 한다.

그럼에도 불구하고 핵심은 간단하다. 작성해야 할 만큼 중요한 코드라면 테스트해야 할 만큼 중요한 것이다. 그러므로 구현한 코드에 대해 개발자 테스트를 작성하라. 코드의 설계를 개선하기 위해 테스트를 이용하라. 구현 코드를 작성하면서 테스트 코드를 작성하라. 테스트의 실행을 자동화하라. 피드백 과정을 줄이라.

테스트는 근본적이고 중요하다. 이번 CHAPTER 11에서는 겉핥기에 그쳤다. 테스트하기를 권장하고 좋은 테스트 기법을 알아보돌 일깨운 것에 불과하다.





